---
title: "In-Class_Ex08: Modelling, Visualising and Analysing Network Data with R"
author: "Roger Chen"
date: "16 Mar 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  freeze: true
  warning: false
  message: false
number-sections: true
editor: visual
---

Before we begin.

First, ensure all the names in the edges document (both source and target) are captured in the nodes document.

![](images/clipboard-1798713629.png)

# Overview

In this in-class exercise, we will learn how to model, analyse and visualise network data using R.

By the end of this exercise, we will be able to:

-   create graph object data frames, manipulate them using appropriate functions of *dplyr*, *lubridate*, and *tidygraph*,

-   build network graph visualisation using appropriate functions of *ggraph*,

-   compute network geometrics using *tidygraph*,

-   build advanced graph visualisation by incorporating the network geometrics, and

-   build interactive network visualisation using *visNetwork* package.

# **Getting Started**

## **Installing and launching R packages**

In this in-class exercise, four network data modelling and visualisation packages will be installed and launched. They are igraph, tidygraph, ggraph and visNetwork. Beside these four packages, tidyverse and [lubridate](https://lubridate.tidyverse.org/), an R package specially designed to handle and wrangling time data will be installed and launched too.

```{r}
pacman::p_load(igraph, tidygraph, ggraph, 
               visNetwork, lubridate, clock,
               tidyverse, graphlayouts)
```

# **Geospatial Data Wrangling**

## **Importing network data from files**

In this step, you will import GAStech_email_node.csv and GAStech_email_edges-v2.csv into RStudio environment by using `read_csv()` of **readr** package.

```{r}
GAStech_nodes <- read_csv("data/GAStech_email_node.csv")
GAStech_edges <- read_csv("data/GAStech_email_edge-v2.csv")
```

## **Wrangling time**

The code chunk below will be used to transform the date to DMY using [lubridate](https://lubridate.tidyverse.org/), and to create a new column to indicate the weekday.

```{r}
GAStech_edges <- GAStech_edges %>%
  mutate(SendDate = dmy(SentDate)) %>%
  mutate(Weekday = wday(SentDate,
                        label = TRUE,
                        abbr = FALSE))
```

## **Reviewing the revised date fields**

Table below shows the data structure of the reformatted *GAStech_edges* data frame.

```{r}
glimpse(GAStech_edges)
```

## **Wrangling attributes**

A close examination of *GAStech_edges* data.frame reveals that it consists of individual e-mail flow records. This is not very useful for visualisation.

In view of this, we will aggregate the individual by date, senders, receivers, main subject and day of the week.

The code chunk:

```{r}
GAStech_edges_aggregated <- GAStech_edges %>%
  filter(MainSubject == "Work related") %>%
  group_by(source, target, Weekday) %>%
    summarise(Weight = n()) %>%
  filter(source!=target) %>%
  filter(Weight > 1) %>%
  ungroup()
```

## **Reviewing the revised edges file**

Table below shows the data structure of the reformatted *GAStech_edges* data frame.

```{r}
glimpse(GAStech_edges_aggregated)
```

# **Creating network objects using tidygraph**

## **Using `tbl_graph()` to build tidygraph data model**

In this section, we will use `tbl_graph()` of **tidygraph** package to build an tidygraph’s network graph data.frame.

```{r}
GAStech_graph <- tbl_graph(nodes = GAStech_nodes,
                           edges = GAStech_edges_aggregated, 
                           directed = TRUE)
```

::: callout-note
If direction of the email matters (Source A sends email to Target B), then directed = TRUE. Otherwise, directed = FALSE
:::

## **Reviewing the output tidygraph’s graph object**

```{r}
GAStech_graph
```

::: callout-note
Take note that the number of nodes and edges in the igraph object should tally with the nodes and edges documents.
:::

## **Changing the active object**

The nodes tibble data frame is activated by default, but you can change which tibble data frame is active with the *activate()* function. Thus, if we wanted to rearrange the rows in the edges tibble to list those with the highest “weight” first, we could use *activate()* and then *arrange()*.

For example,

```{r}
GAStech_graph %>%
  activate(edges) %>%
  arrange(desc(Weight))
```

# **Plotting Static Network Graphs with ggraph package**

[**ggraph**](https://ggraph.data-imaginist.com/) is an extension of **ggplot2**, making it easier to carry over basic ggplot skills to the design of network graphs.

## **Plotting a basic network graph**

The code chunk below uses [*ggraph()*](https://ggraph.data-imaginist.com/reference/ggraph.html), [*geom-edge_link()*](https://ggraph.data-imaginist.com/reference/geom_edge_link.html) and [*geom_node_point()*](https://ggraph.data-imaginist.com/reference/geom_node_point.html) to plot a network graph by using *GAStech_graph*.

```{r}
ggraph(GAStech_graph) +
  geom_edge_link() +
  geom_node_point()
```

::: callout-note
## Things to learn from the code chunk above:

-   The basic plotting function is `ggraph()`, which takes the data to be used for the graph and the type of layout desired. We can also replace geom_edge_link (straight line) with geom_edge_arc (curved line).
:::

## **Changing the default network graph theme**

In this section, we will use [*theme_graph()*](https://ggraph.data-imaginist.com/reference/theme_graph.html) to remove the x and y axes.

```{r}
g <- ggraph(GAStech_graph) + 
  geom_edge_link(aes()) +
  geom_node_point(aes())

g + theme_graph()
```

## **Changing the coloring of the plot**

Furthermore, `theme_graph()` makes it easy to change the coloring of the plot.

```{r}
g <- ggraph(GAStech_graph) + 
  geom_edge_link(aes(colour = 'grey50')) +
  geom_node_point(aes(colour = 'red'))

g + theme_graph(background = 'grey10',
                text_colour = 'white')
```

## **Working with ggraph’s layouts**

**ggraph** support many layout for standard used, they are: star, circle, nicely (default), dh, gem, graphopt, grid, mds, spahere, randomly, fr, kk, drl and lgl. Figures below and on the right show layouts supported by `ggraph()`.

### **dh layout**

The code chunk below will be used to plot the network graph using layout_with_dh() layout.

```{r}
g <- ggraph(GAStech_graph, 
            layout = "dh") +
  geom_edge_link(aes(colour = 'grey50')) +
  geom_node_point(aes(colour = 'red'))

g + theme_graph(background = 'grey10',
                text_colour = 'white')
```

::: callout-note
## Things to learn from the code chunk above:

-   *layout* argument is used to define the layout to be used. You do not need to use the entire syntax "layout_with_dh()", and instead "dh" will suffice.
:::

## **Modifying network nodes**

In this section, we will colour each node by referring to their respective departments.

```{r}
g <- ggraph(GAStech_graph, 
            layout = "nicely") + 
  geom_edge_link(aes(colour = 'red')) +
  geom_node_point(aes(colour = Department, 
                      size = 3))

g + theme_graph()
```

## **Modifying edges**

In the code chunk below, the thickness of the edges will be mapped with the *Weight* variable.

```{r}
g <- ggraph(GAStech_graph, 
            layout = "nicely") +
  geom_edge_link(aes(colour = 'red',
                     width=Weight), 
                 alpha=0.2) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(colour = Department), 
                  size = 3)

g + theme_graph()
```

::: callout-note
## Things to learn from the code chunks above:

-   *geom_edge_link* draws edges in the simplest way - as straight lines between the start and end nodes. But, it can do more that that. In the example above, argument *width* is used to map the width of the line in proportional to the Weight attribute and argument alpha is used to introduce opacity on the line.
:::

# **Creating facet graphs**

Another very useful feature of **ggraph** is faceting. In visualising network data, this technique can be used to reduce edge over-plotting in a very meaning way by spreading nodes and edges out based on their attributes. In this section, we will learn how to use faceting technique to visualise network data.

There are three functions in ggraph to implement faceting, they are:

-   [*facet_nodes()*](https://r4va.netlify.app/chap27) whereby edges are only draw in a panel if both terminal nodes are present here,

-   [*facet_edges()*](https://ggraph.data-imaginist.com/reference/facet_edges.html) whereby nodes are always drawn in al panels even if the node data contains an attribute named the same as the one used for the edge facetting, and

-   [*facet_graph()*](https://ggraph.data-imaginist.com/reference/facet_graph.html) faceting on two variables simultaneously.

## **Working with *facet_edges()***

In the code chunk below, [*facet_edges()*](https://ggraph.data-imaginist.com/reference/facet_edges.html) is used.

```{r}
#| fig-height: 9
#| fig-width: 12

set_graph_style()

g <- ggraph(GAStech_graph, 
            layout = "nicely") + 
  geom_edge_link(aes(width=Weight), 
                 alpha=0.2) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(colour = Department), 
                  size = 2)

g + facet_edges(~Weekday)
```

## **Working with *facet_edges()***

The code chunk below uses *theme()* to change the position of the legend.

```{r}
#| fig-height: 9
#| fig-width: 12

set_graph_style()

g <- ggraph(GAStech_graph, 
            layout = "nicely") + 
  geom_edge_link(aes(width=Weight), 
                 alpha=0.2) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(colour = Department), 
                  size = 2) +
  theme(legend.position = 'bottom')
  
g + facet_edges(~Weekday)
```

## **A framed facet graph**

The code chunk below adds frame to each graph.

```{r}
#| fig-height: 9
#| fig-width: 12

set_graph_style() 

g <- ggraph(GAStech_graph, 
            layout = "nicely") + 
  geom_edge_link(aes(width=Weight), 
                 alpha=0.2) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(colour = Department), 
                  size = 2)
  
g + facet_edges(~Weekday) +
  th_foreground(foreground = "grey80",  
                border = TRUE) +
  theme(legend.position = 'bottom')
```

## **Working with *facet_nodes()***

In the code chunk below, [*facet_nodes()*](https://ggraph.data-imaginist.com/reference/facet_nodes.html) is used.

```{r}
#| fig-height: 9
#| fig-width: 12

set_graph_style()

g <- ggraph(GAStech_graph, 
            layout = "nicely") + 
  geom_edge_link(aes(width=Weight), 
                 alpha=0.2) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(colour = Department), 
                  size = 2)
  
g + facet_nodes(~Department)+
  th_foreground(foreground = "grey80",  
                border = TRUE) +
  theme(legend.position = 'bottom')
```

# **Network Metrics Analysis**

## **Computing centrality indices**

Centrality measures are a collection of statistical indices use to describe the relative important of the actors are to a network. There are four well-known centrality measures, namely: degree, betweenness, closeness and eigenvector.

```{r}
#| fig-height: 9
#| fig-width: 12

g <- GAStech_graph %>%
  mutate(betweenness_centrality = centrality_betweenness()) %>%
  ggraph(layout = "fr") + 
  geom_edge_link(aes(width=Weight), 
                 alpha=0.2) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(colour = Department,
            size=betweenness_centrality))
g + theme_graph()
```

::: callout-note
## Things to learn from the code chunk above:

-   *mutate()* of **dplyr** is used to perform the computation.

-   the algorithm used, on the other hand, is the *centrality_betweenness()* of **tidygraph**.

-   Betweenness_centrality is used to reflect the size of the node.
:::

## **Visualising network metrics**

It is important to note that from **ggraph v2.0** onward tidygraph algorithms such as centrality measures can be accessed directly in ggraph calls. This means that it is no longer necessary to precompute and store derived node and edge centrality measures on the graph in order to use them in a plot.

```{r}
#| fig-height: 9
#| fig-width: 12

g <- GAStech_graph %>%
  ggraph(layout = "fr") + 
  geom_edge_link(aes(width=Weight), 
                 alpha=0.2) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(colour = Department, 
                      size = centrality_betweenness()))
g + theme_graph()
```

## **Visualising Community**

tidygraph package inherits many of the community detection algorithms imbedded into igraph and makes them available to us, including *Edge-betweenness (group_edge_betweenness)*, *Leading eigenvector (group_leading_eigen)*, *Fast-greedy (group_fast_greedy)*, *Louvain (group_louvain)*, *Walktrap (group_walktrap)*, *Label propagation (group_label_prop)*, *InfoMAP (group_infomap)*, *Spinglass (group_spinglass)*, and *Optimal (group_optimal)*. Some community algorithms are designed to take into account direction or weight, while others ignore it. Use this [link](https://tidygraph.data-imaginist.com/reference/group_graph.html) to find out more about community detection functions provided by tidygraph,

In the code chunk below *group_edge_betweenness()* is used.

```{r}
#| fig-height: 9
#| fig-width: 12

g <- GAStech_graph %>%
  mutate(community = as.factor(group_edge_betweenness(weights = Weight, directed = TRUE))) %>%
  ggraph(layout = "fr") + 
  geom_edge_link(aes(width=Weight), 
                 alpha=0.2) +
  scale_edge_width(range = c(0.1, 5)) +
  geom_node_point(aes(colour = community))  

g + theme_graph()
```

# **Building Interactive Network Graph with visNetwork**

-   [visNetwork()](http://datastorm-open.github.io/visNetwork/) is a R package for network visualization, using [vis.js](http://visjs.org/) javascript library.

-   *visNetwork()* function uses a nodes list and edges list to create an interactive graph.

    -   The nodes list must include an “id” column, and the edge list must have “from” and “to” columns.

    -   The function also plots the labels for the nodes, using the names of the actors from the “label” column in the node list.

-   The resulting graph is fun to play around with.

    -   You can move the nodes and the graph will use an algorithm to keep the nodes properly spaced.

    -   You can also zoom in and out on the plot and move it around to re-center it.

## **Data preparation**

Before we can plot the interactive network graph, we need to prepare the data model by using the code chunk below.

```{r}
GAStech_edges_aggregated <- GAStech_edges %>%
  left_join(GAStech_nodes, by = c("sourceLabel" = "label")) %>%
  rename(from = id) %>%
  left_join(GAStech_nodes, by = c("targetLabel" = "label")) %>%
  rename(to = id) %>%
  filter(MainSubject == "Work related") %>%
  group_by(from, to) %>%
    summarise(weight = n()) %>%
  filter(from!=to) %>%
  filter(weight > 1) %>%
  ungroup()
```

## **Plotting the first interactive network graph**

The code chunk below will be used to plot an interactive network graph by using the data prepared.

```{r}
visNetwork(GAStech_nodes, 
           GAStech_edges_aggregated)
```

## **Working with layout**

In the code chunk below, Fruchterman and Reingold layout is used.

```{r}
visNetwork(GAStech_nodes,
           GAStech_edges_aggregated) %>%
  visIgraphLayout(layout = "layout_with_fr") 
```

Visit [Igraph](http://datastorm-open.github.io/visNetwork/igraph.html) to find out more about *visIgraphLayout*’s argument.

## **Working with visual attributes - Nodes**

visNetwork() looks for a field called “group” in the nodes object and colour the nodes according to the values of the group field.

The code chunk below rename Department field to group.

```{r}
GAStech_nodes <- GAStech_nodes %>%
  rename(group = Department) 
```

When we rerun the code chunk below, visNetwork shades the nodes by assigning unique colour to each category in the *group* field.

```{r}
visNetwork(GAStech_nodes,
           GAStech_edges_aggregated) %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visLegend() %>%
  visLayout(randomSeed = 123)
```

## **Working with visual attributes - Edges**

In the code chunk below *visEdges()* is used to symbolise the edges.\
- The argument *arrows* is used to define where to place the arrow.\
- The *smooth* argument is used to plot the edges using a smooth curve.

```{r}
visNetwork(GAStech_nodes,
           GAStech_edges_aggregated) %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visEdges(arrows = "to", 
           smooth = list(enabled = TRUE, 
                         type = "curvedCW")) %>%
  visLegend() %>%
  visLayout(randomSeed = 123)
```

Visit [Option](http://datastorm-open.github.io/visNetwork/edges.html) to find out more about visEdges’s argument.

## **Interactivity**

In the code chunk below, *visOptions()* is used to incorporate interactivity features in the data visualisation.

-   The argument *highlightNearest* highlights nearest when clicking a node.

-   The argument *nodesIdSelection* adds an id node selection creating an HTML select element.

```{r}
visNetwork(GAStech_nodes,
           GAStech_edges_aggregated) %>%
  visIgraphLayout(layout = "layout_with_fr") %>%
  visOptions(highlightNearest = TRUE,
             nodesIdSelection = list(enabled = TRUE,
                                     style = 'background: black;
                                     color: white')) %>%
  visLegend() %>%
  visLayout(randomSeed = 123)
```
